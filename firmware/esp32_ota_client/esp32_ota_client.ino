#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <Update.h>
#include <ArduinoJson.h>
#include <algorithm>
#include "mbedtls/md.h"
#include "secrets.h"

// ==== Device Configuration ==================================================='
// TODO: Replace with your Wi-Fi credentials and OTA token before flashing.
// static const char *WIFI_SSID = "YOUR_WIFI_SSID";
// static const char *WIFI_PASSWORD = "YOUR_WIFI_PASSWORD";
static const char *OTA_TOKEN = "myotatoken";
static const char *OTA_BASE_URL = "https://192.168.0.55:8443";  // OTA server URL
static const char *CURRENT_VERSION = "0.0.1";                     // Bumped after successful flash
// Labels allow server-side grouping (e.g., pilot, canary). Separate multiple labels with commas.
static const char *DEVICE_LABELS = "pilot";

// Embed the self-signed certificate generated by scripts/generate_cert.sh.
// Copy the PEM contents (including BEGIN/END lines) into the string below.
static const char OTA_CA_CERT[] PROGMEM = R"PEM(
-----BEGIN CERTIFICATE-----
MIIFpzCCA4+gAwIBAgIUU5jqNs+t+enoLpOeL/mrwwxWPCQwDQYJKoZIhvcNAQEL
BQAwYzELMAkGA1UEBhMCSlAxDjAMBgNVBAgMBVRva3lvMREwDwYDVQQHDAhTaGlu
anVrdTEPMA0GA1UECgwGS2VpaGluMQwwCgYDVQQLDANPVEExEjAQBgNVBAMMCWxv
Y2FsaG9zdDAeFw0yNTEwMDExMDE5MzNaFw0yNjEwMDExMDE5MzNaMGMxCzAJBgNV
BAYTAkpQMQ4wDAYDVQQIDAVUb2t5bzERMA8GA1UEBwwIU2hpbmp1a3UxDzANBgNV
BAoMBktlaWhpbjEMMAoGA1UECwwDT1RBMRIwEAYDVQQDDAlsb2NhbGhvc3QwggIi
MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCBxYxloy2O0uH1g36CIihn5ZBp
6INs4aVCb/VsHhP9axaM/FAm+lDyFZsGgg5yxF7HNE0KZwup+YV4YuBu5EaQJTqw
ARyi0EMh7yl4H6JhgSXVHal50nsBeT94QZRFGp39q6quxv9oXziFe8dg+/DKvAbc
3nCmDhbOHEql4VSaxXKKKCxz4RurXWWC00ScMFgC14z6GPj/1ochv8E/eyvJrp13
vG4MK3kBLX/KMx8CfPiwu15C7E8VHemp1q9e6kma4Uh1Jeqp1aBPh3ZsEs33vpQk
oOn+52zAYN20WEtQvjbVl3QLekwoH4MHT5sj8LrSN5ol26A9g4Rw4m0XLf+QYi7g
GteimMbd1ONzjfajCFueRL+DajIP3PvTjKEniWCW4UK4s25E1mEi/4kw50NknOuI
R1V0cfBZRuYC1b+nj1njZtKTir/YZ5r2au/iL2f1+spBhRmoU12FtABuvKjKPyYk
TtAzLifv3T2T7tgtXjvRq5Bz1zFf5r+2RToJEGr7mBmaikewXICl2UXtZoIOEoLd
XBjvQ+ihaaMtB3TF6DM99N7vkD1/Z3T4GEPZukzQu9O2DpMB3fPQjqnFSQMAb2D4
fW97fwW3e+u3Wsja8zfacOXnw58ZNeAp2dDW4drdMVn7I8U9LW3++fAz3We/He36
x2aucahzvTj3Lrpu7wIDAQABo1MwUTAdBgNVHQ4EFgQUDZIyAbOSB/fJMdyzu6A5
iMR6pAMwHwYDVR0jBBgwFoAUDZIyAbOSB/fJMdyzu6A5iMR6pAMwDwYDVR0TAQH/
BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAgEAU4Ri84oNKn5v9HnqU6xGeW9llCLk
STH2WAOVf3T5aQSBStcX8b1VJ58MP/2821hwvvWb3prte4MagLm+Tkz6DbgJxqez
7rEIKYrgzY522Mb4hMjMHUiN1c70ksDy9Ei3MwKEX14jeLIbKwbmSeOBa+CVWnTY
iIIg/6vl03f6C6Cg5nDqpnuwGOd8FIiHZ8e9dkS/w692c5nEu5NnAsAoXJfB/7lG
f0Pbs/D6TMcM1+2FfRI0dwXpRUhrXBMcIC2Kb21L0CXnMR9ZR9W9nQ2dHI5vxUxl
lo4nu0Y/VPzNdP4RanAXxFtlfr36mVHfSy+EdM8nlrfpV9uehcdcovtgMf0eE9+1
JijhJEULcHdmNeaUi+ST3xHLAyk3c2QjTwPfGC2iVekogsshGNCv0duWUYBLMb9T
9S5YPvg95fHXbfnxcp4qvFwIXv2gn0kjIVKUjlQMX0ND5pJqIjZOUXF4Z8sWdzYQ
0ha7Htkl2yPfGZw8nFamcfeYKFLXHa80JcMC9yXHPXlzq4cq1qGSqvaswc6ink+i
xN/524bf3h4ltX/QMKUufo3c1K6SoRqfD6vjfLgULHcZs0Re52YewigclOXw5DCM
Hpi2QjHtNZcq6HPQ1KTTiaiJLqm0ckp7aWjAzXydJxeRW2Fdz1c/k+2dakuI6NA7
RTz5ayum3fjFGSU=
-----END CERTIFICATE-----
)PEM";

static const unsigned long DEFAULT_POLL_INTERVAL_MS = 10UL * 60UL * 1000UL;  // 10 minutes fallback
static unsigned long g_nextPollAt = 0;

// ==== Utility helpers ========================================================
static void connectWiFi()
{
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("[OTA] Connecting to Wi-Fi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print('.');
    if (millis() - start > 20000UL) {
      Serial.println("\n[OTA] Wi-Fi connection timeout. Retrying.");
      WiFi.disconnect();
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
      start = millis();
    }
  }
  Serial.printf("\n[OTA] Connected. IP=%s MAC=%s\n", WiFi.localIP().toString().c_str(), WiFi.macAddress().c_str());
}

static bool sha256Init(mbedtls_md_context_t &ctx)
{
  const mbedtls_md_info_t *info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
  if (!info) {
    return false;
  }
  mbedtls_md_init(&ctx);
  if (mbedtls_md_setup(&ctx, info, 0) != 0) {
    return false;
  }
  if (mbedtls_md_starts(&ctx) != 0) {
    return false;
  }
  return true;
}

static bool sha256Update(mbedtls_md_context_t &ctx, const uint8_t *data, size_t len)
{
  return mbedtls_md_update(&ctx, data, len) == 0;
}

static String sha256Finish(mbedtls_md_context_t &ctx)
{
  uint8_t digest[32];
  if (mbedtls_md_finish(&ctx, digest) != 0) {
    return String();
  }
  mbedtls_md_free(&ctx);
  char buf[65];
  for (int i = 0; i < 32; ++i) {
    sprintf(buf + (i * 2), "%02x", digest[i]);
  }
  buf[64] = '\0';
  return String(buf);
}

static void sendReport(const String &mac, const String &version, const String &status, const String &error)
{
  WiFiClientSecure client;
  client.setCACert(OTA_CA_CERT);
  HTTPClient https;
  String endpoint = String(OTA_BASE_URL) + "/api/v1/report-status";
  if (!https.begin(client, endpoint)) {
    Serial.println("[OTA] Failed to begin report-status request");
    return;
  }
  https.addHeader("Content-Type", "application/json");
  https.addHeader("X-OTA-Token", OTA_TOKEN);

  StaticJsonDocument<256> doc;
  doc["mac"] = mac;
  doc["firmware_version"] = version;
  doc["status"] = status;
  if (error.length() > 0) {
    doc["error"] = error;
  }
  String body;
  serializeJson(doc, body);
  int code = https.POST(body);
  if (code > 0) {
    Serial.printf("[OTA] report-status HTTP %d\n", code);
  } else {
    Serial.printf("[OTA] report-status request error: %s\n", https.errorToString(code).c_str());
  }
  https.end();
}

static bool applyFirmware(const String &url, const String &expectedSha, size_t expectedSize)
{
  WiFiClientSecure client;
  client.setCACert(OTA_CA_CERT);
  HTTPClient https;

  Serial.printf("[OTA] Downloading firmware from %s\n", url.c_str());
  if (!https.begin(client, url)) {
    Serial.println("[OTA] HTTPS begin failed");
    return false;
  }

  https.addHeader("X-OTA-Token", OTA_TOKEN);
  int httpCode = https.GET();
  if (httpCode != HTTP_CODE_OK) {
    Serial.printf("[OTA] Firmware download failed, HTTP %d\n", httpCode);
    https.end();
    return false;
  }

  WiFiClient *stream = https.getStreamPtr();
  size_t contentLength = https.getSize();
  if (contentLength <= 0) {
    Serial.println("[OTA] Invalid content length");
    https.end();
    return false;
  }
  if (expectedSize > 0 && contentLength != expectedSize) {
    Serial.printf("[OTA] Size mismatch. Manifest=%u bytes, download=%u bytes\n", static_cast<unsigned>(expectedSize), static_cast<unsigned>(contentLength));
  }

  if (!Update.begin(contentLength)) {
    Serial.println("[OTA] Not enough space for firmware");
    https.end();
    return false;
  }

  mbedtls_md_context_t ctx;
  if (!sha256Init(ctx)) {
    Serial.println("[OTA] SHA256 init failed");
    Update.abort();
    https.end();
    return false;
  }

  uint8_t buffer[1024];
  size_t written = 0;
  while (https.connected() && written < contentLength) {
    size_t available = stream->available();
    if (available) {
      size_t len = stream->readBytes(buffer, std::min(available, sizeof(buffer)));
      if (len == 0) {
        break;
      }
      if (Update.write(buffer, len) != len) {
        Serial.println("[OTA] Update.write error");
        Update.abort();
        https.end();
        mbedtls_md_free(&ctx);
        return false;
      }
      sha256Update(ctx, buffer, len);
      written += len;
    }
    delay(1);
  }

  https.end();

  if (!Update.end()) {
    //Serial.printf("[OTA] Update end failed: %s\n", Update.errorString().c_str());
    Serial.printf("[OTA] Update end failed: %s\n", Update.errorString());
    mbedtls_md_free(&ctx);
    return false;
  }

  String digest = sha256Finish(ctx);
  Serial.printf("[OTA] Firmware SHA256: %s\n", digest.c_str());
  if (!expectedSha.equalsIgnoreCase(digest)) {
    Serial.println("[OTA] Firmware hash mismatch. Aborting.");
    Update.abort();
    return false;
  }

  if (!Update.isFinished()) {
    Serial.println("[OTA] Update not finished. Something went wrong.");
    return false;
  }

  Serial.println("[OTA] Update successful. Rebooting...");
  return true;
}

static void checkForUpdates()
{
  WiFiClientSecure client;
  client.setCACert(OTA_CA_CERT);
  HTTPClient https;

  String endpoint = String(OTA_BASE_URL) + "/api/v1/check-update";
  if (!https.begin(client, endpoint)) {
    Serial.println("[OTA] Failed to begin OTA request");
    return;
  }

  https.addHeader("Content-Type", "application/json");
  https.addHeader("X-OTA-Token", OTA_TOKEN);

  StaticJsonDocument<256> doc;
  doc["mac"] = WiFi.macAddress();
  doc["current_version"] = CURRENT_VERSION;
  JsonArray arr = doc.createNestedArray("labels");
  String labels(DEVICE_LABELS);
  labels.trim();
  if (labels.length() > 0) {
    int start = 0;
    while (start < labels.length()) {
      int comma = labels.indexOf(',', start);
      if (comma < 0) comma = labels.length();
      String token = labels.substring(start, comma);
      token.trim();
      if (token.length() > 0) {
        arr.add(token);
      }
      start = comma + 1;
    }
  }

  String body;
  serializeJson(doc, body);
  int httpCode = https.POST(body);
  if (httpCode != HTTP_CODE_OK) {
    Serial.printf("[OTA] check-update failed: %d %s\n", httpCode, https.errorToString(httpCode).c_str());
    https.end();
    return;
  }

  StaticJsonDocument<512> response;
  DeserializationError err = deserializeJson(response, https.getStream());
  https.end();
  if (err) {
    Serial.printf("[OTA] Failed to parse response: %s\n", err.c_str());
    return;
  }

  bool updateAvailable = response["update_available"].as<bool>();
  unsigned int pollMinutes = response["poll_interval_minutes"].as<unsigned int>();
  if (pollMinutes > 0) {
    g_nextPollAt = millis() + (pollMinutes * 60UL * 1000UL);
  } else {
    g_nextPollAt = millis() + DEFAULT_POLL_INTERVAL_MS;
  }

  if (!updateAvailable) {
    Serial.println("[OTA] No update available.");
    return;
  }

  JsonObject manifest = response["manifest"].as<JsonObject>();
  String version = manifest["version"].as<const char*>();
  String url = manifest["url"].as<const char*>();
  String sha = manifest["sha256"].as<const char*>();
  size_t size = manifest["size_bytes"].as<size_t>();
  Serial.printf("[OTA] Update available: %s (%u bytes)\n", version.c_str(), static_cast<unsigned>(size));

  bool success = applyFirmware(url, sha, size);
  if (success) {
    sendReport(WiFi.macAddress(), version, "success", "");
    delay(1000);
    ESP.restart();
  } else {
    sendReport(WiFi.macAddress(), version, "failed", "applyFirmware");
  }
}

void setup()
{
  Serial.begin(115200);
  delay(2000);
  Serial.printf("[OTA] Client Ver %s started.\n", CURRENT_VERSION);
  connectWiFi();
  g_nextPollAt = millis();
}

void loop()
{
  if (WiFi.status() != WL_CONNECTED) {
    connectWiFi();
  }
  if (millis() > g_nextPollAt) {
    checkForUpdates();
  }
  delay(5000);
}

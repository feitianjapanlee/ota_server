#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <Update.h>
#include <ArduinoJson.h>
#include <algorithm>
#include "mbedtls/md.h"
#include <ESPmDNS.h>
#include "secrets.h"

// ==== Device Configuration ==================================================='
// TODO: Replace with your Wi-Fi credentials and OTA token before flashing.
// static const char *WIFI_SSID = "YOUR_WIFI_SSID";
// static const char *WIFI_PASSWORD = "YOUR_WIFI_PASSWORD";
static const char *OTA_TOKEN = "myotatoken";
static const char *OTA_BASE_URL = "https://otaserver.local:8443";  // OTA server URL
static const char *CURRENT_VERSION = "0.0.1";                     // Bumped after successful flash
// Labels allow server-side grouping (e.g., pilot, canary). Separate multiple labels with commas.
static const char *DEVICE_LABELS = "pilot";

// Embed the self-signed certificate generated by scripts/generate_cert.sh.
// Copy the PEM contents (including BEGIN/END lines) into the string below.
static const char OTA_CA_CERT[] PROGMEM = R"PEM(
-----BEGIN CERTIFICATE-----
MIIFnTCCA4WgAwIBAgIUILIsJsxBKzq/3VyqJtYXw2hBV/cwDQYJKoZIhvcNAQEL
BQAwaTELMAkGA1UEBhMCSlAxDjAMBgNVBAgMBVRva3lvMREwDwYDVQQHDAhTaGlu
anVrdTEPMA0GA1UECgwGS2VpaGluMQwwCgYDVQQLDANPVEExGDAWBgNVBAMMD290
YXNlcnZlci5sb2NhbDAeFw0yNTEwMDcwOTE5NDVaFw0yNjEwMDcwOTE5NDVaMGkx
CzAJBgNVBAYTAkpQMQ4wDAYDVQQIDAVUb2t5bzERMA8GA1UEBwwIU2hpbmp1a3Ux
DzANBgNVBAoMBktlaWhpbjEMMAoGA1UECwwDT1RBMRgwFgYDVQQDDA9vdGFzZXJ2
ZXIubG9jYWwwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDFj2LGXDNm
6Pgqa6TOYA23EnA4YTpPkYKkGvZgWlAO0CyTTg9OX+J4daEY5uDWnTpq8nCaxMyJ
830w9daOW6nj1g+sftEw4XTS3vjnJkeunteQFrs1pQeC0K09UjEwM73mJsN0LF0j
UHMGuFAv/HOJwzMhe7D1/Idr/37VHkeOeSlNDQO0ByZWQLYmTV8z91lRbankgpqZ
OH7/dYX1y8NIoLUDXZ+nFyFz1Oh9ORX8Nj9aqn5oElEHXMb6X+AtZgxuzufzyAQ3
Bvrcd3zR9tghs3S1DGI1cwmwm0NV0p18IiRf9n0R6kxHuh8l6Q8Pl7vNNkdC+H8n
hpxVSacxt2u1jPdNuErdkZgHFyxkORk2MwDsYEAM1a33MSYiRaQF0heIMq1EEgI2
dq+MsrXpbXl3pKnBMBuXUeSlwVTz04AX24cRF5Lri+MbaQrIzWM8m20hXTzZXONr
/MvrPFNvFiVuAWQR5JKhOLrfrlUJTHoBdttXsXF7qEbL2lsiysPUoKfVu2iekkkD
KQ2Bieijd4V0OJwsXD+hE85dfQQNcF4tqjiZjEV1dLZmDqA7ZiqS2J1pErrT4KPJ
HeIphd7R+VtszGhD5dpvVDDSde0bcQUFiwNZskZH2bwwVlLHQZcmLTf7bgXhrdy9
bmicn0ZDkgxQmRzH6+QHDkhzVyJc4wcs7QIDAQABoz0wOzAaBgNVHREEEzARgg9v
dGFzZXJ2ZXIubG9jYWwwHQYDVR0OBBYEFBRtn3mqji4nyWHke3PN00+vQgWjMA0G
CSqGSIb3DQEBCwUAA4ICAQCayCuCc9SKNwhq1r3nMqJCdnwOTOwONtcwN4g3jMj9
pQfjGa/iM4FGPSneM9bM157kvCYMpiBEfkswODppR5PZjdsHrnkjtFDUS/qfKzOE
gVZxj8GqwPEz6CnMUZAdxK5IrECRd6ce5ORzIpmiY89Zo3BjYM2+GOhSHoT/xSOp
wgqo0L54dwhIsspVx8iqUF+Xa0SOApF7reBK1jgNvR0unOTpYC8gtIT3KYN0y8D9
I+1oxPwNX54DdGYkzALY9oGlpLjkxxsLSLObVa2GIvy3f8PNO5Cbg0qBerWKikNH
EfyQDQLY2dOlbL8AHTTmcpLSM3o7Ory6KPEknSv8AURs9djOD/tDoAFpgpE0klMo
wu2uneM9q4slTJWiDmDws4q8wVqz+dqCR1OtAUzMW9JTXP3fTIWEQ5zkvMXoBtVY
YFO5X16P7yfFu3k7XYfRqnDZOnryKLSWmqe7A9nrH1CvWW+RWrs5YtfFax2+LZZ3
tXea0I8wVYQZ3XGrRCBgZvjriy8UvzUMzIIsYu+CobREzR17vcUpss18Y+ObxcxZ
xuNRrmq38nGT6mvZk8cQ2qyonZHq1zemXkhiqoS/C1E2hWWN40OuLM0h5kOJYpBG
rGbAsi8UukZmv0ZAjvp1ZIl8/YwgLAdebQnzimn7GtnJf5b2jRiMLRLQsoozp43x
uA==
-----END CERTIFICATE-----
)PEM";

static const unsigned long DEFAULT_POLL_INTERVAL_MS = 10UL * 60UL * 1000UL;  // 10 minutes fallback
static unsigned long g_nextPollAt = 0;

// ==== Utility helpers ========================================================
static void connectWiFi()
{
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("[OTA] Connecting to Wi-Fi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print('.');
    if (millis() - start > 20000UL) {
      Serial.println("\n[OTA] Wi-Fi connection timeout. Retrying.");
      WiFi.disconnect();
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
      start = millis();
    }
  }
  Serial.printf("\n[OTA] Connected. IP=%s MAC=%s\n", WiFi.localIP().toString().c_str(), WiFi.macAddress().c_str());
  if (MDNS.begin("esp32-ota-client")) {
    Serial.println("[OTA] mDNS responder started: esp32-ota-client.local");
  } else {
    Serial.println("[OTA] Error setting up mDNS responder!");
  }
}

static bool sha256Init(mbedtls_md_context_t &ctx)
{
  const mbedtls_md_info_t *info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
  if (!info) {
    return false;
  }
  mbedtls_md_init(&ctx);
  if (mbedtls_md_setup(&ctx, info, 0) != 0) {
    return false;
  }
  if (mbedtls_md_starts(&ctx) != 0) {
    return false;
  }
  return true;
}

static bool sha256Update(mbedtls_md_context_t &ctx, const uint8_t *data, size_t len)
{
  return mbedtls_md_update(&ctx, data, len) == 0;
}

static String sha256Finish(mbedtls_md_context_t &ctx)
{
  uint8_t digest[32];
  if (mbedtls_md_finish(&ctx, digest) != 0) {
    return String();
  }
  mbedtls_md_free(&ctx);
  char buf[65];
  for (int i = 0; i < 32; ++i) {
    sprintf(buf + (i * 2), "%02x", digest[i]);
  }
  buf[64] = '\0';
  return String(buf);
}

static void sendReport(const String &mac, const String &version, const String &status, const String &error)
{
  WiFiClientSecure client;
  client.setCACert(OTA_CA_CERT);
  HTTPClient https;
  String endpoint = String(OTA_BASE_URL) + "/api/v1/report-status";
  if (!https.begin(client, endpoint)) {
    Serial.println("[OTA] Failed to begin report-status request");
    return;
  }
  https.addHeader("Content-Type", "application/json");
  https.addHeader("X-OTA-Token", OTA_TOKEN);

  StaticJsonDocument<256> doc;
  doc["mac"] = mac;
  doc["firmware_version"] = version;
  doc["status"] = status;
  if (error.length() > 0) {
    doc["error"] = error;
  }
  String body;
  serializeJson(doc, body);
  int code = https.POST(body);
  if (code > 0) {
    Serial.printf("[OTA] report-status HTTP %d\n", code);
  } else {
    Serial.printf("[OTA] report-status request error: %s\n", https.errorToString(code).c_str());
  }
  https.end();
}

static bool applyFirmware(const String &url, const String &expectedSha, size_t expectedSize)
{
  WiFiClientSecure client;
  client.setCACert(OTA_CA_CERT);
  HTTPClient https;

  Serial.printf("[OTA] Downloading firmware from %s\n", url.c_str());
  if (!https.begin(client, url)) {
    Serial.println("[OTA] HTTPS begin failed");
    return false;
  }

  https.addHeader("X-OTA-Token", OTA_TOKEN);
  int httpCode = https.GET();
  if (httpCode != HTTP_CODE_OK) {
    Serial.printf("[OTA] Firmware download failed, HTTP %d\n", httpCode);
    https.end();
    return false;
  }

  WiFiClient *stream = https.getStreamPtr();
  size_t contentLength = https.getSize();
  if (contentLength <= 0) {
    Serial.println("[OTA] Invalid content length");
    https.end();
    return false;
  }
  if (expectedSize > 0 && contentLength != expectedSize) {
    Serial.printf("[OTA] Size mismatch. Manifest=%u bytes, download=%u bytes\n", static_cast<unsigned>(expectedSize), static_cast<unsigned>(contentLength));
  }

  if (!Update.begin(contentLength)) {
    Serial.println("[OTA] Not enough space for firmware");
    https.end();
    return false;
  }

  mbedtls_md_context_t ctx;
  if (!sha256Init(ctx)) {
    Serial.println("[OTA] SHA256 init failed");
    Update.abort();
    https.end();
    return false;
  }

  uint8_t buffer[1024];
  size_t written = 0;
  while (https.connected() && written < contentLength) {
    size_t available = stream->available();
    if (available) {
      size_t len = stream->readBytes(buffer, std::min(available, sizeof(buffer)));
      if (len == 0) {
        break;
      }
      if (Update.write(buffer, len) != len) {
        Serial.println("[OTA] Update.write error");
        Update.abort();
        https.end();
        mbedtls_md_free(&ctx);
        return false;
      }
      sha256Update(ctx, buffer, len);
      written += len;
    }
    delay(1);
  }

  https.end();

  if (!Update.end()) {
    //Serial.printf("[OTA] Update end failed: %s\n", Update.errorString().c_str());
    Serial.printf("[OTA] Update end failed: %s\n", Update.errorString());
    mbedtls_md_free(&ctx);
    return false;
  }

  String digest = sha256Finish(ctx);
  Serial.printf("[OTA] Firmware SHA256: %s\n", digest.c_str());
  if (!expectedSha.equalsIgnoreCase(digest)) {
    Serial.println("[OTA] Firmware hash mismatch. Aborting.");
    Update.abort();
    return false;
  }

  if (!Update.isFinished()) {
    Serial.println("[OTA] Update not finished. Something went wrong.");
    return false;
  }

  Serial.println("[OTA] Update successful. Rebooting...");
  return true;
}

static void checkForUpdates()
{
  WiFiClientSecure client;
  client.setCACert(OTA_CA_CERT);
  HTTPClient https;

  String endpoint = String(OTA_BASE_URL) + "/api/v1/check-update";
  if (!https.begin(client, endpoint)) {
    Serial.println("[OTA] Failed to begin OTA request");
    return;
  }

  https.addHeader("Content-Type", "application/json");
  https.addHeader("X-OTA-Token", OTA_TOKEN);

  StaticJsonDocument<256> doc;
  doc["mac"] = WiFi.macAddress();
  doc["current_version"] = CURRENT_VERSION;
  JsonArray arr = doc.createNestedArray("labels");
  String labels(DEVICE_LABELS);
  labels.trim();
  if (labels.length() > 0) {
    int start = 0;
    while (start < labels.length()) {
      int comma = labels.indexOf(',', start);
      if (comma < 0) comma = labels.length();
      String token = labels.substring(start, comma);
      token.trim();
      if (token.length() > 0) {
        arr.add(token);
      }
      start = comma + 1;
    }
  }

  String body;
  serializeJson(doc, body);
  int httpCode = https.POST(body);
  if (httpCode != HTTP_CODE_OK) {
    Serial.printf("[OTA] check-update failed: %d %s\n", httpCode, https.errorToString(httpCode).c_str());
    https.end();
    return;
  }

  StaticJsonDocument<512> response;
  DeserializationError err = deserializeJson(response, https.getStream());
  https.end();
  if (err) {
    Serial.printf("[OTA] Failed to parse response: %s\n", err.c_str());
    return;
  }

  bool updateAvailable = response["update_available"].as<bool>();
  unsigned int pollMinutes = response["poll_interval_minutes"].as<unsigned int>();
  if (pollMinutes > 0) {
    g_nextPollAt = millis() + (pollMinutes * 60UL * 1000UL);
  } else {
    g_nextPollAt = millis() + DEFAULT_POLL_INTERVAL_MS;
  }

  if (!updateAvailable) {
    Serial.println("[OTA] No update available.");
    return;
  }

  JsonObject manifest = response["manifest"].as<JsonObject>();
  String version = manifest["version"].as<const char*>();
  String url = manifest["url"].as<const char*>();
  String sha = manifest["sha256"].as<const char*>();
  size_t size = manifest["size_bytes"].as<size_t>();
  Serial.printf("[OTA] Update available: %s (%u bytes)\n", version.c_str(), static_cast<unsigned>(size));

  bool success = applyFirmware(url, sha, size);
  if (success) {
    sendReport(WiFi.macAddress(), version, "success", "");
    delay(1000);
    ESP.restart();
  } else {
    sendReport(WiFi.macAddress(), version, "failed", "applyFirmware");
  }
}

void setup()
{
  Serial.begin(115200);
  delay(2000);
  Serial.printf("[OTA] Client Ver %s started.\n", CURRENT_VERSION);
  connectWiFi();
  g_nextPollAt = millis();
}

void loop()
{
  if (WiFi.status() != WL_CONNECTED) {
    connectWiFi();
  }
  if (millis() > g_nextPollAt) {
    checkForUpdates();
  }
  delay(5000);
}
